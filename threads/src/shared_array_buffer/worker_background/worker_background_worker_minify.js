export default function() {
    let worker_background;class AllocatorUseArrayBuffer{share_arrays_memory;constructor(r=new SharedArrayBuffer(0xa00000)){this.share_arrays_memory=r;let e=new Int32Array(this.share_arrays_memory);Atomics.store(e,0,0),Atomics.store(e,1,0),Atomics.store(e,2,12)}static init_self(r){return new AllocatorUseArrayBuffer(r.share_arrays_memory)}async async_write(r,e,t){let o=new Int32Array(this.share_arrays_memory);for(;;){let{value:s}=Atomics.waitAsync(o,0,1);if("timed-out"===(s instanceof Promise?await s:s))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let i=this.write_inner(r,e,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),i}}block_write(r,e,t){for(;;){let o=new Int32Array(this.share_arrays_memory);if("timed-out"===Atomics.wait(o,0,1))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let s=this.write_inner(r,e,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),s}}write_inner(r,e,t){let o,s,i=new Int32Array(this.share_arrays_memory),a=new Uint8Array(this.share_arrays_memory);o=0===Atomics.add(i,1,1)?Atomics.store(i,2,12):Atomics.load(i,2);let n=this.share_arrays_memory.byteLength,c=r.byteLength,l=o+c;if(n<l)throw Error("size is bigger than memory. \nTODO! fix memory limit. support big size another way.");if(r instanceof Uint8Array)s=r;else if(r instanceof Uint32Array){let e=new ArrayBuffer(r.byteLength);new Uint32Array(e).set(r),s=new Uint8Array(e)}a.set(new Uint8Array(s),o),Atomics.store(i,2,l);let m=new Int32Array(e);return Atomics.store(m,t,o),Atomics.store(m,t+1,c),[o,c]}free(r,e){Atomics.sub(new Int32Array(this.share_arrays_memory),1,1)}get_memory(r,e){let t=new ArrayBuffer(e);return new Uint8Array(t).set(new Uint8Array(this.share_arrays_memory).slice(r,r+e)),t}use_defined_memory(r,e,t){new Uint8Array(this.share_arrays_memory).set(new Uint8Array(t).slice(0,e),r)}get_object(){return{share_arrays_memory:this.share_arrays_memory}}}let serialize=r=>({message:r.message,name:r.name,stack:r.stack,cause:r.cause}),WorkerBackground=class r{override_object;allocator;lock;signature_input;workers=[void 0];start_worker;listen_holder;constructor(r,e,t,o){this.override_object=r,this.lock=e??new SharedArrayBuffer(24),this.allocator=t??new AllocatorUseArrayBuffer(new SharedArrayBuffer(10240)),this.signature_input=o??new SharedArrayBuffer(24),this.listen_holder=this.listen()}static init_self(e,t){return new r(e,t.lock,AllocatorUseArrayBuffer.init_self(t.allocator),t.signature_input)}assign_worker_id(){for(let r=1;r<this.workers.length;r++)if(void 0===this.workers[r])return r;return this.workers.push(void 0),this.workers.length-1}ref(){return{allocator:this.allocator.get_object(),lock:this.lock,signature_input:this.signature_input}}async listen(){let r=new Int32Array(this.lock);Atomics.store(r,0,0),Atomics.store(r,1,1);let e=new Int32Array(this.signature_input);for(;;){let{value:t}=Atomics.waitAsync(r,1,1);if(await t==="timed-out")throw Error("timed-out");let o=()=>{let r=Atomics.load(e,1),t=Atomics.load(e,2),o=this.allocator.get_memory(r,t);return this.allocator.free(r,t),new Worker(new TextDecoder().decode(o),{type:1===Atomics.load(e,3)?"module":"classic"})},s=()=>{let r=Atomics.load(e,4),t=Atomics.load(e,5),o=this.allocator.get_memory(r,t);return this.allocator.free(r,t),JSON.parse(new TextDecoder().decode(o))};switch(Atomics.load(e,0)){case 1:{let r=o(),t=s(),i=this.assign_worker_id();console.debug("new worker "+i),this.workers[i]=r;let{promise:a,resolve:n}=Promise.withResolvers();r.onmessage=async r=>{let{msg:e}=r.data;if("ready"===e&&n(),"done"===e&&(this.workers[i].terminate(),this.workers[i]=void 0,console.debug(`worker ${i} done so terminate`)),"error"===e||"exit"===e){this.workers[i].terminate(),this.workers[i]=void 0;let t=0;for(let r of this.workers)void 0!==r&&(r.terminate(),"error"===e?console.warn("wasi throw error but child process exists, terminate "+t):console.debug("wasi exit but child process exists, terminate "+t)),t++;void 0!==this.start_worker&&(this.start_worker.terminate(),"error"===e?console.warn("wasi throw error but wasi exists, terminate wasi"):console.debug("wasi exit but wasi exists, terminate wasi")),this.workers=[void 0],this.start_worker=void 0;let o=new Int32Array(this.lock,12);if("error"===e){let e=r.data.error,t=serialize(e),[s,i]=await this.allocator.async_write(new TextEncoder().encode(JSON.stringify(t)),this.lock,4);if(0!==Atomics.compareExchange(o,0,0,1)){console.error("what happened?"),this.allocator.free(s,i);return}1!==Atomics.notify(o,0)&&(console.error(e),this.allocator.free(s,i),Atomics.store(o,0,0))}else{let e=r.data.code;if(0!==Atomics.compareExchange(o,0,0,2))return void console.error("what happened?");Atomics.store(o,1,e),0===Atomics.notify(o,0)&&Atomics.store(o,0,0)}}},r.postMessage({...this.override_object,...t,worker_id:i,worker_background_ref:this.ref()}),await a,Atomics.store(e,0,i);break}case 2:{console.debug("start worker create"),this.start_worker=o();let r=s();this.start_worker.onmessage=async r=>{let{msg:e}=r.data;if("done"===e){let r=0;for(let e of this.workers)void 0!==e&&(e.terminate(),console.warn("wasi done but worker exists, terminate "+r)),r++;this.start_worker.terminate(),this.start_worker=void 0;let e=new Int32Array(this.lock,12);Atomics.store(e,0,3),0===Atomics.notify(e,0)&&Atomics.store(e,0,0),console.debug("start worker done so terminate")}if("error"===e||"exit"===e){let t=0;for(let r of this.workers)void 0!==r&&(r.terminate(),"error"===e?console.warn("wasi throw error but worker exists, terminate "+t):console.debug("wasi exit but worker exists, terminate "+t)),t++;void 0!==this.start_worker&&(this.start_worker.terminate(),"error"===e?console.warn("wasi throw error but wasi exists, terminate start worker"):console.debug("wasi exit but wasi exists, terminate start worker")),this.workers=[void 0],this.start_worker=void 0;let o=new Int32Array(this.lock,12);if("error"===e){let e=r.data.error,t=serialize(e),[s,i]=await this.allocator.async_write(new TextEncoder().encode(JSON.stringify(t)),this.lock,4);if(0!==Atomics.compareExchange(o,0,0,1)){console.error("what happened?"),this.allocator.free(s,i);return}if(0===Atomics.notify(o,0))throw this.allocator.free(s,i),Atomics.store(o,0,0),e}else{let e=r.data.code;if(0!==Atomics.compareExchange(o,0,0,2))return void console.error("what happened?");Atomics.store(o,1,e),0===Atomics.notify(o,0)&&Atomics.store(o,0,0)}}},this.start_worker.postMessage({...this.override_object,...r,worker_background_ref:this.ref()})}}Atomics.store(r,1,1),Atomics.store(r,2,0),0===Atomics.notify(r,2,1)&&console.warn("notify failed, waiter is late")}}};globalThis.onmessage=r=>{let{override_object:e,worker_background_ref_object:t}=r.data;worker_background=WorkerBackground.init_self(e,t),postMessage("ready")};
}