export const url = () => {
  const code =
    'let worker_background;let serialize=r=>({message:r.message,name:r.name,stack:r.stack,cause:r.cause});class AllocatorUseArrayBuffer{share_arrays_memory;constructor(r=new SharedArrayBuffer(0xa00000)){this.share_arrays_memory=r;let e=new Int32Array(this.share_arrays_memory);Atomics.store(e,0,0),Atomics.store(e,1,0),Atomics.store(e,2,12)}static init_self(r){return new AllocatorUseArrayBuffer(r.share_arrays_memory)}async async_write(r,e,t){let o=new Int32Array(this.share_arrays_memory);for(;;){let{value:s}=Atomics.waitAsync(o,0,1);if("timed-out"===(s instanceof Promise?await s:s))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let i=this.write_inner(r,e,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),i}}block_write(r,e,t){for(;;){let o=new Int32Array(this.share_arrays_memory);if("timed-out"===Atomics.wait(o,0,1))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let s=this.write_inner(r,e,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),s}}write_inner(r,e,t){let o,s;let i=new Int32Array(this.share_arrays_memory),a=new Uint8Array(this.share_arrays_memory);o=0===Atomics.add(i,1,1)?Atomics.store(i,2,12):Atomics.load(i,2);let n=this.share_arrays_memory.byteLength,l=r.byteLength,c=o+l;if(n<c)throw Error("size is bigger than memory. \\nTODO! fix memory limit. support big size another way.");if(r instanceof Uint8Array)s=r;else if(r instanceof Uint32Array){let e=new ArrayBuffer(r.byteLength);new Uint32Array(e).set(r),s=new Uint8Array(e)}a.set(new Uint8Array(s),o),Atomics.store(i,2,c);let m=new Int32Array(e);return Atomics.store(m,t,o),Atomics.store(m,t+1,l),[o,l]}free(r,e){Atomics.sub(new Int32Array(this.share_arrays_memory),1,1)}get_memory(r,e){let t=new ArrayBuffer(e);return new Uint8Array(t).set(new Uint8Array(this.share_arrays_memory).slice(r,r+e)),t}use_defined_memory(r,e,t){new Uint8Array(this.share_arrays_memory).set(new Uint8Array(t).slice(0,e),r)}get_object(){return{share_arrays_memory:this.share_arrays_memory}}}let WorkerBackground=class r{override_object;allocator;lock;signature_input;workers=[void 0];start_worker;listen_holder;constructor(r,e,t,o){this.override_object=r,this.lock=e??new SharedArrayBuffer(20),this.allocator=t??new AllocatorUseArrayBuffer(new SharedArrayBuffer(10240)),this.signature_input=o??new SharedArrayBuffer(24),this.listen_holder=this.listen()}static init_self(e,t){return new r(e,t.lock,AllocatorUseArrayBuffer.init_self(t.allocator),t.signature_input)}assign_worker_id(){for(let r=1;r<this.workers.length;r++)if(void 0===this.workers[r])return r;return this.workers.push(void 0),this.workers.length-1}ref(){return{allocator:this.allocator.get_object(),lock:this.lock,signature_input:this.signature_input}}async listen(){let r=new Int32Array(this.lock);Atomics.store(r,0,0),Atomics.store(r,1,0);let e=new Int32Array(this.signature_input);for(;;)try{let t;let{value:o}=Atomics.waitAsync(r,1,0);if(t=o instanceof Promise?await o:o,"timed-out"===t)throw Error("timed-out");let s=Atomics.load(r,1);if(1!==s)throw Error("locked");let i=()=>{console.log("gen_worker");let r=Atomics.load(e,1),t=Atomics.load(e,2),o=this.allocator.get_memory(r,t);this.allocator.free(r,t);let s=new TextDecoder().decode(o),i=1===Atomics.load(e,3);return new Worker(s,{type:i?"module":"classic"})},a=()=>{console.log("gen_obj");let r=Atomics.load(e,4),t=Atomics.load(e,5),o=this.allocator.get_memory(r,t);this.allocator.free(r,t);let s=new TextDecoder().decode(o);return JSON.parse(s)};switch(Atomics.load(e,0)){case 1:{let r=i(),t=a(),o=this.assign_worker_id();console.log("new worker "+o),this.workers[o]=r;let{promise:s,resolve:n}=Promise.withResolvers();r.onmessage=async r=>{let{msg:e}=r.data;if("ready"===e&&n(),"done"===e&&(this.workers[o].terminate(),this.workers[o]=void 0,console.log(`worker ${o} done so terminate`)),"error"===e){this.workers[o].terminate(),this.workers[o]=void 0;let e=0;for(let r of this.workers)void 0!==r&&(r.terminate(),console.warn("wasi throw error but child process exists, terminate "+e)),e++;void 0!==this.start_worker&&(this.start_worker.terminate(),console.warn("wasi throw error but wasi exists, terminate wasi")),this.workers=[void 0],this.start_worker=void 0;let t=r.data.error,s=new Int32Array(this.lock,8),i=serialize(t),[a,n]=await this.allocator.async_write(new TextEncoder().encode(JSON.stringify(i)),this.lock,3),l=Atomics.compareExchange(s,0,0,1);if(0!==l){console.error("what happened?"),this.allocator.free(a,n);return}let c=Atomics.notify(s,0);0===c&&(console.error(t),this.allocator.free(a,n),Atomics.store(s,0,0))}},r.postMessage({...this.override_object,...t,worker_id:o,worker_background_ref:this.ref()}),await s,Atomics.store(e,0,o);break}case 2:{this.start_worker=i();let r=a();this.start_worker.onmessage=async r=>{let{msg:e}=r.data;if("done"===e){let r=0;for(let e of this.workers)void 0!==e&&(e.terminate(),console.warn("wasi done but worker exists, terminate "+r)),r++;this.start_worker.terminate(),this.start_worker=void 0,console.log("start worker done so terminate")}},this.start_worker.postMessage({...this.override_object,...r,worker_background_ref:this.ref()})}}let n=Atomics.exchange(r,1,0);if(1!==n)throw Error("Lock is already set");let l=Atomics.notify(r,1,1);if(1!==l){if(0===l){console.warn("notify failed, waiter is late");continue}throw Error("notify failed: "+l)}}catch(r){console.error(r),await new Promise(r=>setTimeout(r,1e3))}}};globalThis.onmessage=r=>{let{override_object:e,worker_background_ref_object:t}=r.data;worker_background=WorkerBackground.init_self(e,t),postMessage("ready")};';

  const blob = new Blob([code], { type: "application/javascript" });

  const url = URL.createObjectURL(blob);

  return url;
};
