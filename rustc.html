<meta charset="utf-8">
<script type="module">
    import * as wasi from "./wasi_defs.js";

    class File {
        constructor(data) {
            console.log(data);
            this.data = new Uint8Array(data);
        }

        get size() {
            return this.data.byteLength;
        }

        open() {
            return new OpenFile(this);
        }

        stat() {
            return new wasi.Filestat(this.file_type, this.size);
        }

        truncate() {
            this.data = new Uint8Array([]);
        }
    }

    class OpenFile {
        file_type = wasi.FILETYPE_REGULAR_FILE;

        constructor(file) {
            this.file = file;
            this.file_pos = 0;
        }

        get size() {
            return this.file.size;
        }

        read(len) {
            if (this.file_pos < this.file.data.byteLength) {
                let slice = this.file.data.slice(this.file_pos, this.file_pos + len);
                this.file_pos += slice.length;
                return [slice, 0];
            } else {
                return [[], 0];
            }
        }

        write(buffer) {
            console.log(this.file.data, this.file_pos, buffer.byteLength);
            if (this.file_pos + buffer.byteLength > this.size) {
                let old = this.file.data;
                this.file.data = new Uint8Array(this.file_pos + buffer.byteLength);
                this.file.data.set(old);
            }
            this.file.data.set(
                buffer.slice(
                    0,
                    this.size - this.file_pos,
                ), this.file_pos
            );
            this.file_pos += buffer.byteLength;
            return 0;
        }

        stat() {
            return this.file.stat();
        }
    }

    class Directory {
        file_type = wasi.FILETYPE_DIRECTORY;

        constructor(contents) {
            this.directory = contents;
        }

        open() {
            return this;
        }

        get_entry_for_path(path) {
            let entry = this;
            for (let component of path.split("/")) {
                if (component == "") break;
                if (entry.directory[component] != undefined) {
                    entry = entry.directory[component];
                } else {
                    console.log(component);
                    return null;
                }
            }
            return entry;
        }

        create_entry_for_path(path) {
            let entry = this;
            let components = path.split("/").filter((component) => component != "/");
            for (let i in components) {
                let component = components[i];
                if (entry.directory[component] != undefined) {
                    entry = entry.directory[component];
                } else {
                    console.log("create", component);
                    if (i == components.length - 1) {
                        entry.directory[component] = new File(new ArrayBuffer(0));
                    } else {
                        entry.directory[component] = new Directory({});
                    }
                    entry = entry.directory[component];
                }
            }
            return entry;
        }
    }

    class PreopenDirectory extends Directory {
        constructor(name, contents) {
            super(contents);
            this.prestat_name = new TextEncoder("utf-8").encode(name);
        }
    }

    class Stdio {
        file_type = wasi.FILETYPE_UNKNOWN;

        read(len) {
            throw "unimplemented read from stdio";
        }

        write(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }
    }

    (async function () {
        document.body.style.fontFamily = "monospace";
        document.body.style.whiteSpace = "pre";
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("rustc_binary.wasm"));
        //let wasm = await WebAssembly.compileStreaming(fetch("/rust_out.wasm"));
        document.body.innerText = "Instantiating";

        function fd_err() {
            return -1;
        }

        function read_stdio() {
            throw "unimplemented read_stdio";
        }

        function write_stdio(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }

        function new_directory(name, contents) {
            return new Directory(name, contents);
        }

        async function load_external_file(path) {
            return new File(await (await (await fetch(path)).blob()).arrayBuffer());
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot", "--target", "x86_64-unknown-linux-gnu", "-Cpanic=abort", "-Ccodegen-units=1"];
        let env = ["RUSTC_LOG=trace"];
        let fds = [
            new Stdio(),
            new Stdio(),
            new Stdio(),
            new PreopenDirectory("/tmp", {}),
            new PreopenDirectory(".", {
                "hello.rs": new File(new TextEncoder("utf-8").encode(`fn main() { println!("Hello World!"); }`)),
            }),
            new PreopenDirectory("/sysroot", {
                "lib": new Directory({
                    "rustlib": new Directory({
                        "wasm32-wasi": new Directory({
                            "lib": new Directory({}),
                        }),
                        "x86_64-unknown-linux-gnu": new Directory({
                            "lib": new Directory(await (async function () {
                                let dir = {};
                                for (let file of [
                                    "libcore-b4a7d25c83ac0d14.rlib",
                                    "librustc_std_workspace_core-18038143f92ab7ad.rlib",
                                    "libcompiler_builtins-f0b22b2b55b20afb.rlib",
                                    "liballoc-072489b01506fb72.rlib",
                                    "librustc_std_workspace_alloc-eeb0fd7b28eabbfd.rlib",
                                    "liblibc-f3a5d2870a74e12d.rlib",
                                    "libunwind-d85e8e3df3b56ff5.rlib",
                                    "libcfg_if-6b32ca81b3ffdff5.rlib",
                                    "libbacktrace_sys-93675d780e5d0925.rlib",
                                    "libbacktrace-30a7c0899d033fc0.rlib",
                                    "librustc_demangle-92b41332709a8741.rlib",
                                    "libhashbrown-f92f11aad8210abe.rlib",
                                    "libstd-358912be09271fe6.rlib",
                                    "libpanic_abort-9fa38857c2678ded.rlib",
                                ]) {
                                    dir[file] = await load_external_file("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/" + file);
                                }
                                return dir;
                            })()),
                        }),
                    }),
                }),
            }),
        ];

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                proc_exit() { console.log("proc_exit"); },
                random_get() { console.log("random_get"); },
                args_sizes_get(argc, argv_buf_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer.setUint32(argc, args.length, true);
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer.setUint32(argv_buf_size, buf_size, true);
                    console.log(buffer.getUint32(argc, true), buffer.getUint32(argv_buf_size, true));
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer.setUint32(argv, argv_buf, true);
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer.setUint8(argv_buf + arg.length, 0);
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },

                environ_sizes_get(environ_count, environ_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("environ_sizes_get(", environ_count, ", ", environ_size, ")");
                    buffer.setUint32(environ_count, env.length, true);
                    let buf_size = 0;
                    for (let environ of env) {
                        buf_size += environ.length + 1;
                    }
                    buffer.setUint32(environ_size, buf_size, true);
                    console.log(buffer.getUint32(environ_count, true), buffer.getUint32(environ_size, true));
                    return 0;
                },
                environ_get(environ, environ_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("environ_get(", environ, ", ", environ_buf, ")");
                    let orig_environ_buf = environ_buf;
                    for (let i = 0; i < env.length; i++) {
                        buffer.setUint32(environ, environ_buf, true);
                        environ += 4;
                        let e = new TextEncoder("utf-8").encode(env[i]);
                        buffer8.set(e, environ_buf);
                        buffer.setUint8(environ_buf + e.length, 0);
                        environ_buf += e.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_environ_buf, environ_buf)));
                    return 0;
                },

                clock_time_get(id, precision, time) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    //console.log("clock_time_get(", id, ", ", precision, ", ", time, ")");
                    buffer.setBigUint64(time, 0n, true);
                    return 0;
                },
                fd_close() { console.log("fd_close"); },
                fd_filestat_get(fd, buf) {
                    console.warn("fd_filestat_get(", fd, ", ", buf, ")");
                    if (fds[fd] != undefined) {
                        fds[fd].stat().write_bytes(new DataView(inst.exports.memory.buffer), buf);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    //console.log("fd_read(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nread_ptr, ")");
                    if (fds[fd] != undefined) {
                        buffer.setUint32(nread_ptr, 0, true);
                        for (let i = 0; i < iovs_len; i++) {
                            let iovec = wasi.Iovec.read_bytes(buffer, iovs_ptr + 8 * i);
                            let [data, err] = fds[fd].read(iovec.buf_len);
                            if (err != 0) {
                                return err;
                            }
                            buffer8.set(data, iovec.buf);
                            buffer.setUint32(nread_ptr, buffer.getUint32(nread_ptr, true) + data.length, true);
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_readdir(fd, buf, buf_len, cookie, bufused) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.warn("fd_readdir(", fd, ", ", buf, ", ", buf_len, ", ", cookie, ", ", bufused, ")");
                    // 8 ,  3408816 ,  128 ,  0n ,  1032332
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        buffer.setUint32(bufused, 0, true);

                        console.log(cookie, Object.keys(fds[fd].directory).slice(Number(cookie)));
                        if (cookie >= BigInt(Object.keys(fds[fd].directory).length)) {
                            console.log("end of dir");
                            return 0;
                        }
                        let next_cookie = cookie + 1n;
                        for (let name of Object.keys(fds[fd].directory).slice(Number(cookie))) {
                            let entry = fds[fd].directory[name];
                            console.log(name, entry);
                            let encoded_name = new TextEncoder("utf-8").encode(name);

                            let dirent = new wasi.Dirent(next_cookie, name, entry.file_type);
                            let offset = dirent.length();

                            if ((buf_len - buffer.getUint32(bufused, true)) < offset) {
                                console.log("too small buf");
                                break;
                            } else {
                                console.log("next_cookie =", next_cookie, buf);
                                next_cookie += 1n;
                                dirent.write_bytes(buffer, buffer8, buf);
                                console.log("buffer =", buffer8.slice(buf, buf + offset));
                                buf += offset;
                                buffer.setUint32(bufused, buffer.getUint32(bufused, true) + offset, true);
                                console.log();
                            }
                        }
                        console.log("used =", buffer.getUint32(bufused, true));
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_seek() { console.log("fd_seek"); },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    //console.log("fd_write(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nwritten_ptr, ")");
                    if (fds[fd] != undefined) {
                        buffer.setUint32(nwritten_ptr, 0, true);
                        for (let i = 0; i < iovs_len; i++) {
                            let iovec = wasi.Ciovec.read_bytes(buffer, iovs_ptr + 8 * i);
                            console.log(iovec.buf_len, iovec.buf_len, buffer8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                            let err = fds[fd].write(buffer8.slice(iovec.buf, iovec.buf + iovec.buf_len));
                            if (err != 0) {
                                return err;
                            }
                            buffer.setUint32(nwritten_ptr, buffer.getUint32(nwritten_ptr, true) + iovec.buf_len, true);
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_create_directory() {
                    console.log("path_create_directory");
                },
                path_filestat_get(fd, flags, path_ptr, path_len, buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.warn("path_filestat_get(", fd, ", ", flags, ", ", path_ptr, ", ", path_len, ", ", buf, ")");
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log("file =", path);
                        let entry = fds[fd].get_entry_for_path(path);
                        if (entry == null) {
                            return -1;
                        }
                        // FIXME write filestat_t
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_link() { console.log("path_link"); },
                path_open(fd, dirflags, path_ptr, path_len, oflags, fs_rights_base, fs_rights_inheriting, fdflags, opened_fd_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("path_open(",
                        dirflags, ", ",
                        path_ptr, ", ",
                        path_len, ", ",
                        oflags, ", ",
                        fs_rights_base, ", ",
                        fs_rights_inheriting, ", ",
                        fdflags, ", ",
                        opened_fd_ptr, ")",
                    );
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let entry = fds[fd].get_entry_for_path(path);
                        if (entry == null) {
                            if (oflags & wasi.OFLAGS_CREAT == wasi.OFLAGS_CREAT) {
                                entry = fds[fd].create_entry_for_path(path);
                            } else {
                                return -1;
                            }
                        } else if (oflags & wasi.OFLAGS_EXCL == wasi.OFLAGS_EXCL) {
                            return -1;
                        }
                        if (oflags & wasi.OFLAGS_DIRECTORY == wasi.OFLAGS_DIRECTORY && fds[fd].file_type != wasi.FILETYPE_DIRECTORY) {
                            return -1;
                        }
                        if (oflags & wasi.OFLAGS_TRUNC == wasi.OFLAGS_TRUNC) {
                            entry.truncate();
                        }
                        fds.push(entry.open());
                        let opened_fd = fds.length - 1;
                        buffer.setUint32(opened_fd_ptr, opened_fd, true);
                    } else {
                        return -1;
                    }
                },
                path_readlink() { console.log("path_readlink"); },
                path_remove_directory() { console.log("path_remove_directory"); },
                path_rename() { console.log("path_rename"); },
                path_unlink_file() { console.log("path_unlink_file"); },
                sched_yield() { console.log("sched_yield"); },
                fd_prestat_get(fd, buf_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let prestat = wasi.Prestat.dir(fds[fd].prestat_name.length);
                        prestat.write_bytes(buffer, buf_ptr);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        buffer8.set(fds[fd].prestat_name, path_ptr);
                        return 0;
                    } else {
                        return -1;
                    }
                },
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        try { inst.exports.main(); } catch (e) { console.error(e); }
        document.body.innerText += "\nDone";

        console.log(fds[4].directory);
        console.log(fds[4].directory["hello.hello.7rcbfp3g-cgu.0.rcgu.o"].data);
        document.body.innerHTML += "<br><a href='" + URL.createObjectURL(new Blob([fds[4].directory["hello.hello.7rcbfp3g-cgu.0.rcgu.o"].data], { type: "application/elf" })) + "'>Download object</a>";
        document.body.innerHTML += "<br><a href='" + URL.createObjectURL(new Blob([fds[4].directory["hello.allocator_shim.rcgu.o"].data], { type: "application/elf" })) + "'>Download allocator shim</a>";
    })();
</script>
