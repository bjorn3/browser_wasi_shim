export const url = () => {
  const code =
    'let worker_background;function _define_property(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}let serialize=e=>({message:e.message,name:e.name,stack:e.stack,cause:e.cause});class AllocatorUseArrayBuffer{static init_self(e){return new AllocatorUseArrayBuffer(e.share_arrays_memory)}async async_write(e,r,t){let o=new Int32Array(this.share_arrays_memory);for(;;){let{value:s}=Atomics.waitAsync(o,0,1);if("timed-out"===(s instanceof Promise?await s:s))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let i=this.write_inner(e,r,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),i}}block_write(e,r,t){for(;;){let o=new Int32Array(this.share_arrays_memory);if("timed-out"===Atomics.wait(o,0,1))throw Error("timed-out lock");if(0!==Atomics.compareExchange(o,0,0,1))continue;let s=this.write_inner(e,r,t);return Atomics.store(o,0,0),Atomics.notify(o,0,1),s}}write_inner(e,r,t){let o,s;let i=new Int32Array(this.share_arrays_memory),a=new Uint8Array(this.share_arrays_memory);o=0===Atomics.add(i,1,1)?Atomics.store(i,2,12):Atomics.load(i,2);let n=this.share_arrays_memory.byteLength,l=e.byteLength,c=o+l;if(n<c)throw Error("size is bigger than memory. \\nTODO! fix memory limit. support big size another way.");if(e instanceof Uint8Array)s=e;else if(e instanceof Uint32Array){let r=new ArrayBuffer(e.byteLength);new Uint32Array(r).set(e),s=new Uint8Array(r)}a.set(new Uint8Array(s),o),Atomics.store(i,2,c);let h=new Int32Array(r);return Atomics.store(h,t,o),Atomics.store(h,t+1,l),[o,l]}free(e,r){Atomics.sub(new Int32Array(this.share_arrays_memory),1,1)}get_memory(e,r){let t=new ArrayBuffer(r);return new Uint8Array(t).set(new Uint8Array(this.share_arrays_memory).slice(e,e+r)),t}use_defined_memory(e,r,t){new Uint8Array(this.share_arrays_memory).set(new Uint8Array(t).slice(0,r),e)}get_object(){return{share_arrays_memory:this.share_arrays_memory}}constructor(e=new SharedArrayBuffer(0xa00000)){_define_property(this,"share_arrays_memory",void 0),this.share_arrays_memory=e;let r=new Int32Array(this.share_arrays_memory);Atomics.store(r,0,0),Atomics.store(r,1,0),Atomics.store(r,2,12)}}let WorkerBackground=class e{static init_self(r,t){return new e(r,t.lock,AllocatorUseArrayBuffer.init_self(t.allocator),t.signature_input)}assign_worker_id(){for(let e=1;e<this.workers.length;e++)if(void 0===this.workers[e])return e;return this.workers.push(void 0),this.workers.length-1}ref(){return{allocator:this.allocator.get_object(),lock:this.lock,signature_input:this.signature_input}}async listen(){let e=new Int32Array(this.lock);Atomics.store(e,0,0),Atomics.store(e,1,0);let r=new Int32Array(this.signature_input);for(;;)try{let t;let{value:o}=Atomics.waitAsync(e,1,0);if(t=o instanceof Promise?await o:o,"timed-out"===t)throw Error("timed-out");let s=Atomics.load(e,1);if(1!==s)throw Error("locked");let i=()=>{console.log("gen_worker");let e=Atomics.load(r,1),t=Atomics.load(r,2),o=this.allocator.get_memory(e,t);this.allocator.free(e,t);let s=new TextDecoder().decode(o),i=1===Atomics.load(r,3);return new Worker(s,{type:i?"module":"classic"})},a=()=>{console.log("gen_obj");let e=Atomics.load(r,4),t=Atomics.load(r,5),o=this.allocator.get_memory(e,t);this.allocator.free(e,t);let s=new TextDecoder().decode(o);return JSON.parse(s)};switch(Atomics.load(r,0)){case 1:{let e=i(),t=a(),o=this.assign_worker_id();console.log("new worker "+o),this.workers[o]=e;let{promise:s,resolve:n}=Promise.withResolvers();e.onmessage=async e=>{let{msg:r}=e.data;if("ready"===r&&n(),"done"===r&&(this.workers[o].terminate(),this.workers[o]=void 0,console.log(`worker ${o} done so terminate`)),"error"===r){this.workers[o].terminate(),this.workers[o]=void 0;let r=0;for(let e of this.workers)void 0!==e&&(e.terminate(),console.warn("wasi throw error but child process exists, terminate "+r)),r++;void 0!==this.start_worker&&(this.start_worker.terminate(),console.warn("wasi throw error but wasi exists, terminate wasi")),this.workers=[void 0],this.start_worker=void 0;let t=e.data.error,s=new Int32Array(this.lock,8),i=serialize(t),[a,n]=await this.allocator.async_write(new TextEncoder().encode(JSON.stringify(i)),this.lock,3),l=Atomics.compareExchange(s,0,0,1);if(0!==l){console.error("what happened?"),this.allocator.free(a,n);return}let c=Atomics.notify(s,0);0===c&&(console.error(t),this.allocator.free(a,n),Atomics.store(s,0,0))}},e.postMessage({...this.override_object,...t,worker_id:o,worker_background_ref:this.ref()}),await s,Atomics.store(r,0,o);break}case 2:{this.start_worker=i();let e=a();this.start_worker.onmessage=async e=>{let{msg:r}=e.data;if("done"===r){let e=0;for(let r of this.workers)void 0!==r&&(r.terminate(),console.warn("wasi done but worker exists, terminate "+e)),e++;this.start_worker.terminate(),this.start_worker=void 0,console.log("start worker done so terminate")}},this.start_worker.postMessage({...this.override_object,...e,worker_background_ref:this.ref()})}}let n=Atomics.exchange(e,1,0);if(1!==n)throw Error("Lock is already set");let l=Atomics.notify(e,1,1);if(1!==l){if(0===l){console.warn("notify failed, waiter is late");continue}throw Error("notify failed: "+l)}}catch(e){console.error(e),await new Promise(e=>setTimeout(e,1e3))}}constructor(e,r,t,o){_define_property(this,"override_object",void 0),_define_property(this,"allocator",void 0),_define_property(this,"lock",void 0),_define_property(this,"signature_input",void 0),_define_property(this,"workers",[void 0]),_define_property(this,"start_worker",void 0),_define_property(this,"listen_holder",void 0),this.override_object=e,this.lock=r??new SharedArrayBuffer(20),this.allocator=t??new AllocatorUseArrayBuffer(new SharedArrayBuffer(10240)),this.signature_input=o??new SharedArrayBuffer(24),this.listen_holder=this.listen()}};globalThis.onmessage=e=>{let{override_object:r,worker_background_ref_object:t}=e.data;worker_background=WorkerBackground.init_self(r,t),postMessage("ready")};';

  const blob = new Blob([code], { type: "application/javascript" });

  const url = URL.createObjectURL(blob);

  return url;
};
